<!-- Slide number: 1 -->

第五章 动态规划法
Chapter 5 Dynamic Programming
计算机学院  高翔
gaoxg@nwpu.edu.cn

<!-- Slide number: 2 -->
5.1动态规划概述
5.2 求解三角形最小路径问题
5.3求解最长公共子序列问题
5.4求解最长递增子序列问题
5.5求解0/1背包问题
5.6完全加括号的矩阵连乘积
5.8 求解资源分配问题
目  录
5.7 动态规划算法的基本要素

<!-- Slide number: 3 -->
5.1.1  从求解斐波那契数列看动态规划法

求解斐波那契数列的递归算法
int count=1;		//累计调用的步骤
int Fib(int n)		//算法
{  printf("(%d)求解Fib(%d)\n"count++n);
   if (n==1 || n==2)
   {  printf("   计算出Fib(%d)=%d\n"n1);
      return 1;
   }
   else
   {  int x=Fib(n-1);
      int y=Fib(n-2);
      printf("   计算出Fib(%d)=Fib(%d)+Fib(%d)=%d\n"
				nn-1n-2x+y);
      return x+y;
   }
}
5.1 动态规划概述

<!-- Slide number: 4 -->
Fib(5)时的输出结果
1求解Fib(5)
2求解Fib(4)
3求解Fib(3)
4求解Fib(2)
   计算出Fib(2)=1
5求解Fib(1)
   计算出Fib(1)=1
   计算出Fib(3)=Fib(2)+Fib(1)=2
6求解Fib(2)
   计算出Fib(2)=1
   计算出Fib(4)=Fib(3)+Fib(2)=3
7求解Fib(3)
8求解Fib(2)
   计算出Fib(2)=1
9求解Fib(1)
   计算出Fib(1)=1
   计算出Fib(3)=Fib(2)+Fib(1)=2
   计算出Fib(5)=Fib(4)+Fib(3)=5

<!-- Slide number: 5 -->
从中看出如下几点
   1递归调用Fib(5)采用自顶向下的执行过程从调用Fib(5)开始到计算出Fib(5)结束
   2计算过程中存在大量的重复计算例如求Fib(5)的过程如图8.1所示存在两次重复计算Fib(3)值的情况
Fib(5)
Fib(4)
Fib(3)
Fib(2)
Fib(2)
Fib(1)
Fib(3)
Fib(2)
Fib(1)

<!-- Slide number: 6 -->

![Picture 2](Picture2.jpg)

<!-- Slide number: 7 -->
    为此避免重复设计设计一个dp数组dp[i]存放Fib(i)的值首先设置dp[1]和dp[2]均为1再让i从3到n循环以计算dp[3]到dp[n]的值最后返回dp[n]即Fib1(n)对应的算法1如下
int dp[MAX];				//所有元素初始化为0
int count=1;				//累计调用的步骤
int Fib1(int n)			//算法1
{  dp[1]=dp[2]=1;
   printf("(%d)计算出Fib(1)=1\n"count++);
   printf("(%d)计算出Fib(2)=1\n"count++);
   for (int i=3;i<=n;i++)
   {  dp[i]=dp[i-1]+dp[i-2];
      printf("(%d)计算出Fib(%d)=%d\n"count++idp[i]);
   }
   return dp[n];
}

<!-- Slide number: 8 -->
执行Fib(5)时的输出结果如下
1计算出Fib(1)=1
2计算出Fib(2)=1
3计算出Fib(3)=2
4计算出Fib(4)=3
5计算出Fib(5)=5

<!-- Slide number: 9 -->
    其执行过程改变为自底向上即先求出子问题解将计算结果存放在一张表中而且相同的子问题只计算一次在后面需要时只有简单查表以避免大量的重复计算
Fib(5)
Fib(4)
Fib(3)
Fib(2)
Fib(2)
Fib(1)
Fib(3)
查表得到
查表得到

<!-- Slide number: 10 -->
    上述求斐波那契数列的算法1属于动态规划法其中数组dp表称为动态规划数组动态规划法也称为记录结果再利用的方法其基本求解过程如下图所示
原问题

<!-- Slide number: 11 -->
5.1.2 动态规划的原理
        动态规划是一种解决多阶段决策问题的优化方法把多阶段过程转化为一系列单阶段问题利用各阶段之间的关系逐个求解

<!-- Slide number: 12 -->
1. 动态规划的相关概念
    示例在A处有一水库现需要从A点铺设一条管道到E点边上的数字表示与其相连的两个地点之间所需修建的管道长度用c数组表示例如c(AB1)=2现要找出一条从A到E的修建线路使得所需修建的管道长度最短

<!-- Slide number: 13 -->
A
B1
B2
B3
C1
C2
C3
D1
D2
E
2
4
3
7
4
3
2
6
5
3
4
6
3
3
3
4
3
4
2
    在从AE的过程中依据按位置所做的决策的次数及所做决策的先后次序将问题分为5个阶段阶段变量用于表示各阶段这里阶段变量k为15图中第5阶段是虚拟的一个边界阶段

<!-- Slide number: 14 -->
    设最优指标函数f(s)表示状态s到终点E的最短路径长度用k表示阶段则对应的状态转移方程如下
S2={B1B2B3}
s2取S2的元素
D2(B1)={C1C2}
x2取D2(B1)的元素
符号示例

<!-- Slide number: 15 -->
2. 动态规划问题的解法
逆序解法
顺序解法

<!-- Slide number: 16 -->
1动态规划问题的逆序解法
求解EA的过程用next表示路径上一个顶点的后继顶点
 第5阶段
f(E)=0
 第4阶段
f(D1)=MIN(c(D1E)+f(E))=3 next(D1)=E
f(D2)=MIN(c(D2E)+f(E))=4 next(D2)=E

<!-- Slide number: 17 -->
 第3阶段

![Picture 1](Picture1.jpg)
f(D1)=3
f(D2)=4

<!-- Slide number: 18 -->
 第2阶段

![Picture 2](Picture2.jpg)
f(C1)=6
f(C2)=7
f(C3)=6

<!-- Slide number: 19 -->
 第1阶段

![Picture 2](Picture2.jpg)
    由f(A)=12求出的最短路径长度为12
    由next(A)=B3next(B3)=C2next(C2)=D2next(D2)=E推出最短路径为AB3C2D2E
f(B1)=11
f(B2)=9
f(B3)=9

<!-- Slide number: 20 -->
2动态规划问题的顺序解法
AE对应的的状态转移方程如下

<!-- Slide number: 21 -->
用pre表示路径上一个顶点的前驱顶点其求解AE的过程
 第1阶段
f(A)=0
 第2阶段
f(B1)=MIN(f(A)+c(AB1))=2 pre(B1)=A
f(B2)=MIN(f(A)+c(AB2))=4 pre(B2)=A
f(B3)=MIN(f(A)+c(AB3))=3 pre(B3)=A

<!-- Slide number: 22 -->
 第3阶段

![Picture 2](Picture2.jpg)
f(B1)=2
f(B2)=4
f(B3)=3

<!-- Slide number: 23 -->
 第4阶段

![Picture 2](Picture2.jpg)
f(C1)=7
f(C2)=5
f(C3)=8

<!-- Slide number: 24 -->
 第5阶段

![Picture 2](Picture2.jpg)
    由f(E)=12求出的最短路径长度为12
    由pre(E)=D2pre(D2)=C2pre(C2)=B3pre(B3)=A推出最短路径为AB3C2D2E

f(D1)=10
f(D2)=8

<!-- Slide number: 25 -->
5.1.3 动态规划求解的基本步骤
能采用动态规划求解的问题的一般要具有3个性质
最优性原理如果问题的最优解所包含的子问题的解也是最优的就称该问题具有最优子结构即满足最优性原理
无后效性即某阶段状态一旦确定就不受这个状态以后决策的影响也就是说某状态以后的过程不会影响以前的状态只与当前状态有关
有重叠子问题即子问题之间是不独立的一个子问题在下一阶段决策中可能被多次使用到该性质并不是动态规划适用的必要条件但是如果没有这条性质动态规划算法同其他算法相比就不具备优势

<!-- Slide number: 26 -->
实际应用中简化的步骤
 分析最优解的性质并刻画其结构特征
 递归的定义最优解
 以自底向上或自顶向下的记忆化方式计算出最优值
 根据计算最优值时得到的信息构造问题的最优解

<!-- Slide number: 27 -->
5.1.4 动态规划与其他方法的比较
动态规划的基本思想与分治法类似也是将待求解的问题分解为若干个子问题阶段按顺序求解子阶段前一子问题的解为后一子问题的求解提供了有用的信息
在求解任一子问题时列出各种可能的局部解通过决策保留那些有可能达到最优的局部解丢弃其他局部解依次解决各子问题最后一个子问题就是初始问题的解

<!-- Slide number: 28 -->
动态规划方法又和贪心法有些相似在动态规划中可将一个问题的解决方案视为一系列决策的结果
不同的是在贪心法中每采用一次贪心准则便做出一个不可回溯的决策还要考察每个最优决策序列中是否包含一个最优子序列

<!-- Slide number: 29 -->
   问题描述给定高度为n的一个整数三角形找出从顶部到底部的最小路径和只能向下移动相邻的结点首先输入n接下来的1n行第i 行输入i 个整数输出分为2行第一行为最小路径第2行为最小路径和
   例如下图是一个n=4的三角形输出的路径是2 3 5 3最小路径是13
2
3
4
5
7
6
8
3
9
2
5.2 求解三角形最小路径问题

<!-- Slide number: 30 -->
    问题求解将三角形采用二维数组a存放前面的三角形对应的二维数组如下
     从顶部到底部查找最小路径那么结点ij的前驱结点只有i-1j-1和i-1j两个

<!-- Slide number: 31 -->
     从顶部到底部查找最小路径那么结点ij的前驱结点只有i-1j-1和i-1j两个
a[][]
dp[][]
pre[][]

<!-- Slide number: 32 -->
     dp[i][j]表示从顶部a[0][0]查找到ij结点时的最小路径和显然这里有两个边界即第1列和对角线达到它们中结点的路径只有一条而不是常规的两条所以状态转移方程如下
dp[0][0]=a[0][0]			顶部边界
dp[i][0]=dp[i-1][0]+a[i][0]		考虑第1列的边界1in-1
dp[i][i]=dp[i-1][i-1]+a[i][i]		考虑对角线的边界1in-1
dp[i][j]=min(dp[i-1][j-1]dp[i-1][j])+a[i][j]  i>1的其他有两						  条达到路径的结点
最后求出的最小路径和ans=min(dp[n-1][j])以及对应的列号k

<!-- Slide number: 33 -->
    用pre[i][j]表示查找到ij结点时最小路径上的前驱结点由于前驱结点只有两个即i-1j-1和i-1j用pre[i][j]记录前驱结点的列号即可
     在求出ans后通过pre[n-1][k]反推求出反向路径最后正向输出该路径
由dp求一条路径

<!-- Slide number: 34 -->
//问题表示
int a[MAXN][MAXN];
int n;
//求解结果表示
int ans=0;
int dp[MAXN][MAXN];
int pre[MAXN][MAXN];

<!-- Slide number: 35 -->
int Search()			//求最小和路径ans
{  int ij;
   dp[0][0]=a[0][0];
   for(i=1;i<n;i++)		//考虑第1列的边界
   {  dp[i][0]=dp[i-1][0]+a[i][0];
      pre[i][0]=0;
   }
   for (i=1;i<n;i++)		//考虑对角线的边界
   {  dp[i][i]=a[i][i]+dp[i-1][i-1];
      pre[i][i]=i-1;
   }

<!-- Slide number: 36 -->
   for(i=2;i<n;i++)		//考虑其他有两条达到路径的结点
   {  for(j=1;j<i;j++)
      {  if(dp[i-1][j-1]<dp[i-1][j])
         {  pre[i][j]=j-1;
            dp[i][j]=a[i][j]+dp[i-1][j-1];
         }
         else
         {  pre[i][j]=j;
            dp[i][j]=a[i][j]+dp[i-1][j];
         }
      }
   }

<!-- Slide number: 37 -->
   ans=dp[n-1][0];
   int k=0;
   for (j=1;j<n;j++)		//求出最小ans和对应的列号k
   {  if (ans>dp[n-1][j])
      {  ans=dp[n-1][j];
         k=j;
      }
   }
   return k;
}

<!-- Slide number: 38 -->
int main()
{  int k;
   memset(pre0sizeof(pre));
   memset(dp0sizeof(dp));
   scanf("%d"&n);			//输入三角形的高度
   for (int i=0;i<n;i++)		//输入三角形
      for (int j=0;j<=i;j++)
         scanf("%d"&a[i][j]);
   k=Search();				//求最小路径和
   Disppath(k);			//输出正向路径
   printf("%d\n"ans);		//输出最小路径和
   return 0;
}

<!-- Slide number: 39 -->
   算法分析Search()算法中有i从2到n-1j从1到i-1的两重循环容易求出时间复杂度为O(n2)

<!-- Slide number: 40 -->
    问题描述字符序列的子序列是指从给定字符序列中随意地不一定连续去掉若干个字符可能一个也不去掉后所形成的字符序列
    令给定的字符序列X=x0x1xm-1序列Y=y0y1yk-1是X的子序列存在X的一个严格递增下标序列i0i1ik-1使得对所有的j=01k-1有    =yj 
    例如X=abcbdabY=bcdb是X的一个子序列
    给定两个序列A和B称序列Z是A和B的公共子序列是指Z同是A和B的子序列该问题是求两序列A和B的最长公共子序列LCS

5.3 求解最长公共子序列问题

<!-- Slide number: 41 -->
   问题求解若设A=a0a1am-1B=b0b1bn-1设Z=z0z1zk-1为它们的最长公共子序列不难证明有以下性质
如果am-1=bn-1则zk-1=am-1=bn-1且z0z1zk-2是a0a1am-2和b0b1bn-2的一个最长公共子序列
如果am-1bn-1且zk-1am-1则z0z1zk-1是a0a1am-2和b0b1bn-1的一个最长公共子序列
如果am-1bn-1且zk-1bn-1则z0z1zk-1是a0a1am-1和b0b1bn-2的一个最长公共子序列

<!-- Slide number: 42 -->
    定义二维动态规划数组dp其中dp[i][j]为子序列a0a1ai-1和b0b1bj-1的最长公共子序列的长度
    每考虑一个字符a[i]或b[j]都为动态规划的一个阶段共经历约m×n个阶段

<!-- Slide number: 43 -->
    定义二维动态规划数组dp其中dp[i][j]为子序列a0a1ai-1和b0b1bj-1的最长公共子序列的长度
    每考虑一个字符a[i]或b[j]都为动态规划的一个阶段共经历约m×n个阶段
情况2a[i-1]b[j-1]

<!-- Slide number: 44 -->
    dp[i][j]为子序列a0a1ai-1和b0b1bj-1的最长公共子序列的长度
    对应的状态转移方程如下
dp[i][j]=0				  i=0或j=0边界条件
dp[i][j]=dp[i-1][j-1]+1		  a[i-1]=b[j-1]
dp[i][j]=MAX(dp[i][j-1]dp[i-1][j])	  a[i-1]b[j-1]
显然dp[m][n]为最终结果

<!-- Slide number: 45 -->
dp[i][j]=0				  i=0或j=0边界条件
dp[i][j]=dp[i-1][j-1]+1		  a[i-1]=b[j-1]
dp[i][j]=MAX(dp[i][j-1]dp[i-1][j])	  a[i-1]b[j-1]
Y(j)

<!-- Slide number: 46 -->
那么如何由dp求出一个LCS呢
dp[i][j]=0				  i=0或j=0边界条件
dp[i][j]=dp[i-1][j-1]+1		  a[i-1]=b[j-1]
dp[i][j]=MAX(dp[i][j-1]dp[i-1][j])	  a[i-1]b[j-1]
当dp[i][j]  dp[i][j-1]左边并且dp[i][j]  dp[i-1][j]上方值时
     a[i-1]=b[j-1]   它是LCS的一个字符
将a[i-1]添加到LCS中
 其他情况时a[i-1]或者b[j-1]是LCS的一个字符

<!-- Slide number: 47 -->
总 结
1如果dp[i][j]==dp[i-1][j]上方说明a[i-1]或b[j-1]不是LCS中的字符      i--
2如果dp[i][j]==dp[i][j-1]左边说明a[i-1]或b[j-1]不是LCS中的字符         j--
3其他情况说明a[i-1]或者b[j-1]是LCS的一个字符
                 i--;     j--; k--;表示求的字符减少1个
用vector<char>字符向量subs存放一个LCSk=dp[m][n]LCS的字符个数从k到1循环求出subs中的k个字符

<!-- Slide number: 48 -->
    例如X=abcbdbm=6Y=acbbabdbbn=9
Y(j)
1求出dp
d
b

<!-- Slide number: 49 -->
   那么如何由dp求出LCS呢例如X=abcbdbm=6Y=acbbabdbbn=9
a
0
0
0
0
0
0
0
0
c
0
1
1
1
1
1
1
1
b
0
1
1
2
2
2
2
2
b
0
1
2
2
3
3
3
3
a
0
1
2
2
3
3
4
4
b
0
1
2
2
3
3
4
5
d
0
1
2
2
3
3
4
6
b
0
1
2
2
3
4
4
7
b
0
1
2
2
3
4
5
8
0
1
2
2
3
4
5
9
0
1
2
3
4
5
6
a
b
c
b
d
b

X

Y
1求出dp
2dp[6][9]=5开始
2
3
4
5
LCS
c
b
d
b
i=4j=5

<!-- Slide number: 50 -->
    那么如何由dp求出LCS呢例如X=abcbdbm=6Y=acbbabdbbn=9
a
0
0
0
0
0
0
0
0
c
0
1
1
1
1
1
1
1
b
0
1
1
2
2
2
2
2
b
0
1
2
2
3
3
3
3
a
0
1
2
2
3
3
4
4
b
0
1
2
2
3
3
4
5
d
0
1
2
2
3
3
4
6
b
0
1
2
2
3
4
4
7
b
0
1
2
2
3
4
5
8
0
1
2
2
3
4
5
9
0
1
2
3
4
5
6
a
b
c
b
d
b

X

Y
1求出dp
2dp[6][9]=5开始
1
2
3
4
5
LCS
a
c
b
d
b
i=2j=1
结果LCS="acbdb"

<!-- Slide number: 51 -->
#define MAX 51				//序列中最多的字符个数
//问题表示
int mn;
string ab;				//求解结果表示
int dp[MAX][MAX];			//动态规划数组
vector<char> subs;			//存放LCS

<!-- Slide number: 52 -->
void LCSlength()			//求dp
{  int ij;
   for (i=0;i<=m;i++)			//将dp[i][0]置为0边界条件
      dp[i][0]=0;
   for (j=0;j<=n;j++)			//将dp[0][j]置为0边界条件
      dp[0][j]=0;
   for (i=1;i<=m;i++)
      for (j=1;j<=n;j++)	   //两重for循环处理ab的所有字符
      {  if (a[i-1]==b[j-1])		//情况(1)
            dp[i][j]=dp[i-1][j-1]+1;
         else				//情况(2)
            dp[i][j]=max(dp[i][j-1]dp[i-1][j]);
      }
}

<!-- Slide number: 53 -->
void Buildsubs()		 //由dp构造从subs
{  int k=dp[m][n];		 //k为a和b的最长公共子序列长度
   int i=m;
   int j=n;
   while (k>0)			 //在subs中放入最长公共子序列(反向)
     if (dp[i][j]==dp[i-1][j])
	i--;
     else if (dp[i][j]==dp[i][j-1])
	j--;
     else			 //与上方左边元素值均不相等
     {	 subs.push_back(a[i-1]);  //subs中添加a[i-1]
	 i--; j--; k--;
     }
}

<!-- Slide number: 54 -->
   算法分析 LCSlength算法中使用了两重循环所以对于长度分别为m和n的序列求其最长公共子序列的时间复杂度为O(m×n)空间复杂度为O(m×n)

<!-- Slide number: 55 -->
   问题描述给定一个无序的整数序列a[0..n-1]求其中最长递增子序列的长度
    例如a[]={215364897}n=9其最长递增子序列为{13489}结果为5
5.4 求解最长递增子序列问题

<!-- Slide number: 56 -->
    问题求解设计动态规划数组为一维数组dpdp[i]表示a[0..i]中以a[i]结尾的最长递增子序列的长度对应的状态转移方程如下
dp[i]=1				0in-1
dp[i]=max(dp[i]dp[j]+1)	若a[i]>a[j]0in-10ji-1
求出dp后其中最大元素即为所求

<!-- Slide number: 57 -->

| i | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| a\[i] | 2 | 1 | 5 | 3 | 6 | 4 | 8 | 9 | 7 |
| dp\[i] | 1 | 1 | 2 | 2 | 3 | 3 | 4 | 5 | 4 |
dp[i]=1				0in-1
dp[i]=max(dp[i]dp[j]+1)	若a[i]>a[j]0in-10ji-1

<!-- Slide number: 58 -->
//问题表示
int a[]={215364897};
int n=sizeof(a)/sizeof(a[0]);
//求解结果表示
int ans=0;
int dp[MAX];
void solve(int a[]int n)
{  int ij;
   for(i=0;i<n;i++)
   {  dp[i]=1;
      for(j=0;j<i;j++)
      {  if (a[i]>a[j])
           dp[i]=max(dp[i]dp[j]+1);
      }
   }
   ans=dp[0];
   for(i=1;i<n;i++)
     ans=max(ansdp[i]);
}

<!-- Slide number: 59 -->
算法分析solve()算法中含两重循环时间复杂度为O(n2)

<!-- Slide number: 60 -->
问题描述有n个重量分别为{w1w2wn}的物品它们的价值分别为{v1v2vn}给定一个容量为W的背包
    设计从这些物品中选取一部分物品放入该背包的方案每个物品要么选中要么不选中要求选中的物品不仅能够放到背包中而且重量和为W具有最大的价值
5.5 求解0/1背包问题

<!-- Slide number: 61 -->
    问题求解对于可行的背包装载方案背包中物品的总重量不能超过背包的容量
     最优方案是指所装入的物品价值最高即 v1*x1+v2*x2++vn*xn其中xi取0或1取1表示选取物品i取得最大值
     在该问题中需要确定x1x2xn的值假设按i=12n的次序来确定xi的值对应n次决策即n个阶段

<!-- Slide number: 62 -->
      设置二维动态规划数组dpdp[i][r]表示背包剩余容量为r1rW已考虑物品12i1in时背包装入物品的最优价值显然对应的状态转移方程如下
这样 dp[n][W]便是0/1背包问题的最优解
dp[i][0]=0背包不能装入任何物品总价值为0
			边界条件dp[i][0]=01in边界条件
dp[0][r]=0没有任何物品可装入总价值为0
			边界条件dp[0][r]=01rW边界条件
dp[i][r]=dp[i-1][r]	当r<w[i]时物品i放不下
dp[i][r]= MAX{dp[i-1][r]dp[i-1][r-w[i]]+v[i]}
			否则在不放入和放入物品i之间选最优解

<!-- Slide number: 63 -->
当dp数组计算出来后推导出解向量x的过程十分简单从dp[n][W]开始
    1若dp[i][r]dp[i-1][r]若dp[i][r]=dp[i-1][r-w[i]]+v[i]置x[i]=1累计总价值maxv+=v[i]递减剩余重量r=r-w[i]
    2若dp[i][r]=dp[i-1][r]表示物品i放不下或者不放入物品i置x[i]=0
dp[i][r]=dp[i-1][r]	当r<w[i]时物品i放不下
dp[i][r]= MAX{dp[i-1][r]dp[i-1][r-w[i]]+v[i]}
			否则在不放入和放入物品i之间选最优解

<!-- Slide number: 64 -->
     例如某0/1背包问题为n=5w={22654}v={63546}下标从1开始W=10
求出dp
dp[i][r]=dp[i-1][r]	当r<w[i]时物品i放不下
dp[i][r]= MAX{dp[i-1][r]dp[i-1][r-w[i]]+v[i]}
			否则在不放入和放入物品i之间选最优解

<!-- Slide number: 65 -->
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
6
6
6
6
6
2
0
6
6
6
6
6
3
0
6
9
9
9
9
4
0
6
9
9
9
9
5
0
6
9
9
9
12
6
0
6
9
9
10
12
7
0
6
9
11
11
15
8
0
6
9
11
13
15
9
0
1
2
3
4
5

i

r
0
6
9
14
14
15
10
回推求最优解的过程
dp[5][10] dp[4][10]
      x[5]=1r=r-w[5]=6
i=5r=W=10从dp[5][10]开始

i=i-1=4dp[4][6]=dp[3][6]
      x[4]=0
i=i-1=3dp[3][6]=dp[2][6]
      x[3]=0
i=i-1=2dp[2][6]dp[1][6]
      x[2]=1r=r-w[2]=4
i=i-1=1dp[1][4]dp[0][4]
      x[1]=1r=r-w[1]=2

14
15
6
9
9
9
0
6
w={22654}

<!-- Slide number: 66 -->
//问题表示
int n=5W=10;			//5种物品限制重量不超过10
int w[MAXN]={022654};	//下标0不用
int v[MAXN]={063546};	//下标0不用
//求解结果表示
int dp[MAXN][MAXW];
int x[MAXN];
int maxv; 			//存放最优解的总价值

<!-- Slide number: 67 -->
void Knap()			//动态规划法求0/1背包问题
{  int ir;
   for (i=0;i<=n;i++)		//置边界条件dp[i][0]=0
      dp[i][0]=0;
   for (r=0;r<=W;r++)		//置边界条件dp[0][r]=0
      dp[0][r]=0;
   for (i=1;i<=n;i++)
   {  for (r=1;r<=W;r++)
        if (r<w[i])
           dp[i][r]=dp[i-1][r];
        else
           dp[i][r]=max(dp[i-1][r]dp[i-1][r-w[i]]+v[i]);
   }
}

<!-- Slide number: 68 -->
void Buildx()				//回推求最优解
{  int i=nr=W;
   maxv=0;
   while (i>=0)			//判断每个物品
   {
      if (dp[i][r]!=dp[i-1][r])
      {  x[i]=1;			//选取物品i
         maxv+=v[i];			//累计总价值
         r=r-w[i];
      }
      else
        x[i]=0;			//不选取物品i
      i--;
   }
}

<!-- Slide number: 69 -->
   算法分析Knap()算法中含有两重for循环所以时间复杂度为O(n×W)空间复杂度为O(n×W)

<!-- Slide number: 70 -->
16000, 10500, 36000, 87500, 34500
完全加括号的矩阵连乘积可递归地定义为
1单个矩阵是完全加括号的
2矩阵连乘积A 是完全加括号的则 A可
       表示为2个完全加括号的矩阵连乘积 B和C
       的乘积并加括号即A=BC
设有四个矩阵                  它们的维数分别是

总共有五中完全加括号的方式
5.6 完全加括号的矩阵连乘积

### Notes:
10*40*30=12000,10*30*5=1500,50*10*5=2500,16000
40*30*5=6000,40*5*10=2000,50*10*5=2500,10500

<!-- Slide number: 71 -->
给定n个矩阵                            其中     与         是可乘的                         考察这n个矩阵的连乘积

由于矩阵乘法满足结合律所以计算矩阵的连乘可以有许多不同的计算次序这种计算次序可以用加括号的方式来确定
若一个矩阵连乘积的计算次序完全确定也就是说该连乘积已完全加括号则可以依此次序反复调用2个矩阵相乘的标准算法计算出矩阵连乘积

<!-- Slide number: 72 -->
     给定n个矩阵A1,A2,,An其中Ai与Ai+1是可乘的i=1,2 ,,n-1如何确定计算矩阵连乘积的计算次序使得依此次序计算矩阵连乘积需要的数乘次数最少
穷举法列举出所有可能的计算次序并计算出每一种计算次序相应需要的数乘次数从中找出一种数乘次数最少的计算次序

<!-- Slide number: 73 -->
穷举法
动态规划
将矩阵连乘积                       简记为A[i:j] 这里ij
考察计算A[i:j]的最优计算次序设这个计算次序在矩阵
Ak和Ak+1之间将矩阵链断开ik<j则其相应完全
加括号方式为
计算量A[i:k]的计算量加上A[k+1:j]的计算量再加上
A[i:k]和A[k+1:j]相乘的计算量

<!-- Slide number: 74 -->
分析最优解的结构
特征计算A[i:j]的最优次序所包含的计算矩阵子链 A[i:k]和A[k+1:j]的次序也是最优的
矩阵连乘计算次序问题的最优解包含着其子问题的最优解这种性质称为最优子结构性质问题的最优子结构性质是该问题可用动态规划算法求解的显著特征

<!-- Slide number: 75 -->
建立递归关系
设计算A[i:j]1ijn所需要的最少数乘次数m[i,j]则原问题的最优值为m[1,n]
当i=j时A[i:j]=Ai因此m[i,i]=0i=1,2,,n
当i<j时

可以递归地定义m[i,j]为

   k的位置只有j-i 种可能

<!-- Slide number: 76 -->
int matrixchain(int i,int j)
{ if(i==j) return 0;
  int u=matrixchain(i+1,j)+p[i-1]*p[i]*p[j];
  s[i][j]=i; //初始化断点位置为i
  for(int k=i+1;k<j;k++){
   int t;
   t=matrixchain(i,k)+matrixchain(k+1,j)+p[i-1]*p[k]*p[j];
   if(t<u){
      u=t;
      s[i][j]=k;}
    }//end for
   return u;
}

<!-- Slide number: 77 -->

![Picture 2](Picture2.jpg)

<!-- Slide number: 78 -->
计算最优值
对于1ijn不同的有序对(i,j)对应于不同的子问题不同子问题的个数最多只有(n2).
在递归计算时许多子问题被重复计算多次这也是该问题可用动态规划算法求解的又一显著特征
用动态规划算法解此问题可依据其递归式以自底向上的方式进行计算在计算过程中保存已解决的子问题答案每个子问题只计算一次而在后面需要时只要简单查一下从而避免大量的重复计算最终得到多项式时间的算法

<!-- Slide number: 79 -->

![1](Picture6.jpg)

| A1 | A2 | A3 | A4 | A5 | A6 |
| --- | --- | --- | --- | --- | --- |
| 3035 | 3515 | 155 | 510 | 1020 | 2025 |

### Notes:
30*35*15=15750,35*15*5=2625,15*5*10=750
1:3 从2断开15750+30*15*5=18000,从1断开30*35*5+2625=7875所以m[1][3]=7875, s[1][3]=1;
2:4 从2断开750+35*15*10=6000从3断开2625+35*5*10=4375所以m[2][4]=4375,s[2][4]=3
3:5 ,4:6
1:4 从1断开4375+30*35*10=14875从2断开15750+750+30*15*10=20250从3断开7875+30*5*10=9375所以m[1][4]=9375,s[1][4]=3

<!-- Slide number: 80 -->

![1](Picture6.jpg)

| A1 | A2 | A3 | A4 | A5 | A6 |
| --- | --- | --- | --- | --- | --- |
| 3035 | 3515 | 155 | 510 | 1020 | 2025 |

<!-- Slide number: 81 -->

public static void matrixChain(int [] p, int [][] m, int [][] s)
   {
      int n=p.length-1;
      for (int i = 1; i <= n; i++) m[i][i] = 0;
      for (int r = 2; r <= n; r++)  //2到n列
         for (int i = 1; i <= n - r+1; i++) { //1到n-r+1行
            int j=i+r-1;
            m[i][j] = m[i+1][j]+ p[i-1]*p[i]*p[j];
            s[i][j] = i;

<!-- Slide number: 82 -->
for (int k = i+1; k < j; k++) {
               int t = m[i][k] + m[k+1][j] + p[i-1]*p[k]*p[j];
               if (t < m[i][j]) {
                 m[i][j] = t;
                 s[i][j] = k;}
               }//end for k
            }//end for i
   }// end for
}// end function

![t31](Picture4.jpg)

<!-- Slide number: 83 -->

![t31](Picture4.jpg)

| A1 | A2 | A3 | A4 | A5 | A6 |
| --- | --- | --- | --- | --- | --- |
| 3035 | 3515 | 155 | 510 | 1020 | 2025 |
(A1(A2A3))(A4A5)A6)

<!-- Slide number: 84 -->
算法复杂度分析
算法matrixChain的主要计算量取决于算法中对ri和k的3重循环循环体内的计算量为O(1)而3重循环的总次数为O(n3)因此算法的计算时间上界为O(n3)算法所占用的空间显然为O(n2)

<!-- Slide number: 85 -->
一最优子结构

矩阵连乘计算次序问题的最优解包含着其子问题的最优解这种性质称为最优子结构性质
在分析问题的最优子结构性质时所用的方法具有普遍性首先假设由问题的最优解导出的子问题的解不是最优的然后再设法说明在这个假设下可构造出比原问题最优解更好的解从而导致矛盾
利用问题的最优子结构性质以自底向上的方式递归地从子问题的最优解逐步构造出整个问题的最优解最优子结构是问题能用动态规划算法求解的前提
注意同一个问题可以有多种方式刻划它的最优子结构有些表示方法的求解速度更快空间占用小问题的维度低
5.7 动态规划算法的基本要素

<!-- Slide number: 86 -->
二重叠子问题

递归算法求解问题时每次产生的子问题并不总是新问题有些子问题被反复计算多次这种性质称为子问题的重叠性质
动态规划算法对每一个子问题只解一次而后将其解保存在一个表格中当再次需要解此子问题时只是简单地用常数时间查看一下结果
通常不同的子问题个数随问题的大小呈多项式增长因此用动态规划算法只需要多项式时间从而获得较高的解题效率

<!-- Slide number: 87 -->
三备忘录方法

备忘录方法的控制结构与直接递归方法的控制结构相同区别在于备忘录方法为每个解过的子问题建立了备忘录以备需要时查看避免了相同子问题的重复求解

<!-- Slide number: 88 -->
private static int lookupChain(int i, int j)
   {
     if (m[i][j] > 0) return m[i][j];
     if (i == j) return 0;
     int u = lookupChain(i+1,j) + p[i-1]*p[i]*p[j];
     s[i][j] = i;
     for (int k = i+1; k < j; k++) {
      int t ;
      t= lookupChain(i,k) + lookupChain(k+1,j) + p[i-1]*p[k]*p[j];
        if (t < u) {
          u = t; s[i][j] = k;}
        }//end for
      m[i][j] = u;
      return u;
   }

<!-- Slide number: 89 -->
   问题描述资源分配问题是将数量一定的一种或若干种资源原材料资金设备或劳动力等合理地分配给若干使用者使总收益最大
     例如某公司有3个商店ABC拟将新招聘的5名员工分配给这3个商店各商店得到新员工后每年的赢利情况如下表所示求分配给各商店各多少员工才能使公司的赢利最大

| 员工数 商店 | 0人 | 1人 | 2人 | 3人 | 4人 | 5人 |
| --- | --- | --- | --- | --- | --- | --- |
| A | 0 | 3 | 7 | 9 | 12 | 13 |
| B | 0 | 5 | 10 | 11 | 11 | 11 |
| C | 0 | 4 | 6 | 11 | 12 | 12 |

5.8 求解资源分配问题

<!-- Slide number: 90 -->
    问题求解采用动态规划求解该问题设置3个商店ABC的编号分别为13
    这里总员工数为n=5商店个数m=3假设从商店3开始决策起
    设置二维动态规划数组为dp其中dp[i][s]表示考虑商店i商店m并分配s个人后的最优赢利
    另外设置二维数组pnum其中pnum[i][s]表示求出dp[i][s]时对应商店i的分配人数

<!-- Slide number: 91 -->
对应的状态转移方程如下

显然dp[1][n]就是最优赢利
dp[m+1][j]=0			  边界条件类似终点的dp值为0
dp[i][s]=max(v[i][j]+dp[i+1][s-j])	pnum[i][s]=dp[i][s]取最					大值的j0jn
从商店m  商店1反向求解

<!-- Slide number: 92 -->
//问题表示
int m=3,n=5;				//商店数为m,总人数为n
int v[MAXM][MAXN]={{0,0,0,0,0,0},{0,3,7,9,12,13},
	{0,5,10,11,11,11},{0,4,6,11,12,12}}; //不计v[0]行
//求解结果表示
int dp[MAXM][MAXN];
int pnum[MAXM][MAXN];

<!-- Slide number: 93 -->
void Plan()			  //求最优方案dp
{  int maxf,maxj;
   for (int j=0;j<=n;j++)	  //置边界条件
     dp[m+1][j]=0;
   for (int i=m;i>=1;i--)	  //i从商店3到1进行处理
   {  for (int s=1;s<=n;s++)	  //分配的总人数为s
      {  maxf=0;
         maxj=0;
         for (j=0;j<=s;j++)//找该商店最优情况maxf和分配人数maxj
         {  if ((v[i][j]+dp[i+1][s-j])>=maxf)
            {  maxf=v[i][j]+dp[i+1][s-j];
               maxj=j;
            }
         }
         dp[i][s]=maxf;
         pnum[i][s]=maxj;
      }
   }
}

<!-- Slide number: 94 -->
最优资源分配方案如下:
  C商店分配3人
  B商店分配2人
  A商店分配0人
  该分配方案的总赢利为21万元

| 员工数 商店 | 0人 | 1人 | 2人 | 3人 | 4人 | 5人 |
| --- | --- | --- | --- | --- | --- | --- |
| A | 0 | 3 | 7 | 9 | 12 | 13 |
| B | 0 | 5 | 10 | 11 | 11 | 11 |
| C | 0 | 4 | 6 | 11 | 12 | 12 |

### Notes:

<!-- Slide number: 95 -->
商店1
选择人数
dp[1][*]
pnum[1][*]
阶段1
商店2
选择人数
dp[2][*]
pnum[2][*]
阶段2
商店m
选择人数
dp[1][*]
pnum[i][*]
阶段m
商店0
选择人数
dp[0][*]=0
阶段0

虚拟
商店个数m总员工数为n
分配的总员工数为n
dp[i][s]表示考虑商店1i并分配s个人后的最优赢利
补充从商店1  商店m正向求解

### Notes:

<!-- Slide number: 96 -->
对应的状态转移方程如下

dp[m][n]就是最优赢利pnum为最优分配方案
dp[0][j]=0  边界条件类似终点的dp值为0

dp[i][s]=max( v[i][j]+dp[i-1][s-j] )
    pnum[i][s]=dp[i][s]取最大值的j1sn,0js

商店i选择j个人
dp[i][s]表示考虑商店1i并分配s个人后的最优赢利

### Notes:

<!-- Slide number: 97 -->
最优资源分配方案如下:
  C商店分配3人
  B商店分配2人
  A商店分配0人
  该分配方案的总赢利为21万元

| 员工数 商店 | 0人 | 1人 | 2人 | 3人 | 4人 | 5人 |
| --- | --- | --- | --- | --- | --- | --- |
| A | 0 | 3 | 7 | 9 | 12 | 13 |
| B | 0 | 5 | 10 | 11 | 11 | 11 |
| C | 0 | 4 | 6 | 11 | 12 | 12 |

### Notes:

<!-- Slide number: 98 -->

![Picture 2](Picture2.jpg)